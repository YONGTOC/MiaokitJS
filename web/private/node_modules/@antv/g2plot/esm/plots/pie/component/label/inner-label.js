import { __extends } from "tslib";
import { registerElementLabels } from '@antv/g2';
import * as _ from 'lodash';
import { getEndPoint, getOverlapInfo } from './utils';
import BaseLabel from './base-label';
import { distBetweenPoints } from '../../../../util/math';
export function percent2Number(value) {
    var percentage = Number(value.endsWith('%') ? value.slice(0, -1) : value);
    return percentage / 100;
}
/**
 * @desc 饼图 inner-label 布局
 * @done
 */
var InnerLabel = /** @class */ (function (_super) {
    __extends(InnerLabel, _super);
    function InnerLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InnerLabel.prototype.adjustPosition = function (labels, items, coord) {
        var _this = this;
        var center = coord.getCenter();
        var radius = coord.getRadius();
        var offset = this.getOffsetOfLabel();
        var r = radius + offset;
        labels.forEach(function (label, idx) {
            var anchor = items.find(function (i) { return i.id === label.id; });
            var _a = getEndPoint(center, anchor.angle, r), newX = _a.x, newY = _a.y;
            label.attr('x', newX);
            label.attr('y', newY);
            label.attr('textBaseline', 'middle');
            if (idx > 0) {
                var prevLabel = labels[idx - 1];
                _this.resolveCollision(label, prevLabel, anchor, coord);
            }
        });
    };
    /** @override inner布局不需要拉线 */
    InnerLabel.prototype.adjustLines = function (labels, items, labelLines, coord) {
        labelLines.forEach(function (l) { return l.set('visible', false); });
    };
    /** @override */
    InnerLabel.prototype.adjustLabelText = function () { };
    /** @override 不能大于0 */
    InnerLabel.prototype.getOffsetOfLabel = function () {
        var labelOptions = this.get('labelOptions');
        var offset = labelOptions.offset;
        var radius = this.get('coord').getRadius();
        if (_.isString(offset)) {
            offset = radius * percent2Number(offset);
        }
        return offset > 0 ? 0 : offset;
    };
    /** label 碰撞调整 */
    InnerLabel.prototype.resolveCollision = function (label, prev, anchor, coord) {
        var angle = anchor.angle;
        var box = label.getBBox();
        var prevBBox = prev.getBBox();
        var pos = { x: (box.minX + box.maxX) / 2, y: (box.minY + box.maxY) / 2 };
        // 两种调整方案
        /** 先偏移 x 方向 -> 再计算 y 位置 */
        var pos1 = _.clone(pos);
        /** 先偏移 y 方向 -> 再计算 x 位置 */
        var pos2 = _.clone(pos);
        // check overlap
        if (prev.id !== label.id) {
            var _a = getOverlapInfo(box, prevBBox), xOverlap = _a.xOverlap, yOverlap = _a.yOverlap;
            if (xOverlap) {
                pos1.x = pos.x + xOverlap;
                pos1.y = pos.y + Math.tan(angle) * xOverlap;
            }
            if (yOverlap) {
                // fix issue-460
                var yMover = yOverlap;
                var center = coord.getCenter();
                if (pos.y < center.y) {
                    // 上方label优先往上偏移
                    yMover = yMover < 0 ? yMover : prevBBox.minY - box.maxY;
                }
                else {
                    // 下方label优先往下偏移
                    yMover = yMover > 0 ? yMover : prevBBox.maxY - box.minY;
                }
                pos2.y = pos.y + yMover;
                pos2.x = pos.x + yMover / Math.tan(angle);
            }
            var dist1 = distBetweenPoints(pos, pos1);
            var dist2 = distBetweenPoints(pos, pos2);
            var actualPos = dist1 < dist2 ? pos1 : pos2;
            // 取偏移距离最小的
            label.attr('x', actualPos.x);
            label.attr('y', actualPos.y);
        }
    };
    return InnerLabel;
}(BaseLabel));
registerElementLabels('inner', InnerLabel);
//# sourceMappingURL=inner-label.js.map