"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var g_1 = require("@antv/g");
var _ = tslib_1.__importStar(require("@antv/util"));
var global_1 = require("../../theme/global");
function getOverlappingPadding(layer, components) {
    var bleeding = global_1.getGlobalTheme().bleeding;
    if (_.isArray(bleeding)) {
        _.each(bleeding, function (it, index) {
            if (typeof bleeding[index] === 'function') {
                bleeding[index] = bleeding[index]({});
            }
        });
    }
    var viewMinX = layer.layerBBox.minX;
    var viewMaxX = layer.layerBBox.maxX;
    var viewMinY = _.clone(layer.layerBBox.minY);
    var viewMaxY = layer.layerBBox.maxY;
    _.each(components, function (component) {
        var position = component.position;
        var _a = component.getBBox(), minX = _a.minX, maxX = _a.maxX, minY = _a.minY, maxY = _a.maxY;
        if (maxY > viewMinY && maxY < viewMaxY && position === 'top') {
            viewMinY = maxY;
        }
        if (minY > viewMinY && minY < viewMaxY && position === 'bottom') {
            viewMaxY = minY;
        }
        if (maxX > viewMinX && maxX < viewMaxX && position === 'left') {
            viewMinX = maxX;
        }
        if (minX > viewMinX && maxX < viewMaxX && position === 'right') {
            viewMaxX = minX;
        }
    });
    var range = new g_1.BBox(viewMinX, viewMinY, viewMaxX - viewMinX, viewMaxY - viewMinY);
    var top_padding = range.minY - layer.layerBBox.minY;
    if (top_padding === 0) {
        top_padding = bleeding[0];
    }
    var right_padding = layer.layerBBox.maxX - range.maxX;
    var bottom_padding = layer.layerBBox.maxY - range.maxY;
    var left_padding = range.minX - layer.layerBBox.minX;
    return [top_padding, right_padding, bottom_padding, left_padding];
}
exports.getOverlappingPadding = getOverlappingPadding;
//# sourceMappingURL=padding.js.map