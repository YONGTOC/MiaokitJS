"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Util = require("@antv/util");
var shape_1 = require("../core/shape");
var Inside = require("./util/inside");
var bbox_1 = require("../core/bbox");
var CText = /** @class */ (function (_super) {
    tslib_1.__extends(CText, _super);
    function CText() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.canFill = true;
        _this.canStroke = true;
        _this.type = 'text';
        return _this;
    }
    CText.prototype.getDefaultAttrs = function () {
        return {
            x: 0,
            y: 0,
            text: null,
            lineHeight: 1,
            lineWidth: 1,
            lineCount: 1,
            fontSize: 12,
            fontFamily: 'sans-serif',
            fontStyle: 'normal',
            fontWeight: 'normal',
            fontVariant: 'normal',
            textAlign: 'start',
            textBaseline: 'bottom',
            textArr: null,
        };
    };
    CText.prototype.isPointInPath = function (x, y) {
        var self = this;
        var box = self.getBBox();
        if (self.hasFill() || self.hasStroke()) {
            return Inside.box(box.x, box.maxX, box.minY, box.maxY, x, y);
        }
    };
    CText.prototype.initTransform = function () {
        var fontSize = this.attrs.fontSize;
        if (fontSize && +fontSize < 12) {
            // 小于 12 像素的文本进行 scale 处理
            this.transform([
                ['t', -1 * this.attrs.x, -1 * this.attrs.y],
                ['s', +fontSize / 12, +fontSize / 12],
                ['t', this.attrs.x, this.attrs.y],
            ]);
        }
    };
    CText.prototype._assembleFont = function () {
        // var self = this;
        var attrs = this.attrs;
        var fontSize = attrs.fontSize;
        var fontFamily = attrs.fontFamily;
        var fontWeight = attrs.fontWeight;
        var fontStyle = attrs.fontStyle; // self.attr('fontStyle');
        var fontVariant = attrs.fontVariant; // self.attr('fontVariant');
        // self.attr('font', [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' '));
        attrs.font = [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' ');
    };
    CText.prototype._setAttrText = function () {
        var attrs = this.attrs;
        var text = attrs.text;
        var textArr = null;
        if (Util.isString(text) && text.indexOf('\n') !== -1) {
            textArr = text.split('\n');
            var lineCount = textArr.length;
            attrs.lineCount = lineCount;
        }
        attrs.textArr = textArr;
    };
    CText.prototype._getTextHeight = function () {
        var attrs = this.attrs;
        var lineCount = attrs.lineCount;
        var fontSize = attrs.fontSize * 1;
        if (lineCount > 1) {
            var spaceingY = this._getSpaceingY();
            return fontSize * lineCount + spaceingY * (lineCount - 1);
        }
        return fontSize;
    };
    CText.prototype.isHitBox = function () {
        return false;
    };
    CText.prototype.calculateBox = function () {
        var self = this;
        var attrs = self.attrs;
        var cfg = this.cfg;
        if (!cfg.attrs || cfg.hasUpdate) {
            this._assembleFont();
            this._setAttrText();
        }
        if (!attrs.textArr) {
            this._setAttrText();
        }
        var x = attrs.x;
        var y = attrs.y;
        var width = self.measureText(); // attrs.width
        if (!width) {
            // 如果width不存在，四点共其实点
            return new bbox_1.default(x, y, 0, 0);
        }
        var height = self._getTextHeight(); // attrs.height
        var textAlign = attrs.textAlign;
        var textBaseline = attrs.textBaseline;
        var lineWidth = self.getHitLineWidth();
        var point = {
            x: x,
            y: y - height,
        };
        if (textAlign) {
            if (textAlign === 'end' || textAlign === 'right') {
                point.x -= width;
            }
            else if (textAlign === 'center') {
                point.x -= width / 2;
            }
        }
        if (textBaseline) {
            if (textBaseline === 'top') {
                point.y += height;
            }
            else if (textBaseline === 'middle') {
                point.y += height / 2;
            }
        }
        this.set('startPoint', point);
        var halfWidth = lineWidth / 2;
        return bbox_1.default.fromRange(point.x - halfWidth, point.y - halfWidth, point.x + width + halfWidth, point.y + height + halfWidth);
    };
    CText.prototype._getSpaceingY = function () {
        var attrs = this.attrs;
        var lineHeight = attrs.lineHeight;
        var fontSize = attrs.fontSize * 1;
        return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    };
    CText.prototype.drawInner = function (context) {
        var self = this;
        var attrs = self.attrs;
        var cfg = this.cfg;
        if (!cfg.attrs || cfg.hasUpdate) {
            this._assembleFont();
            this._setAttrText();
        }
        context.font = attrs.font;
        var text = attrs.text;
        if (Util.isNil(text)) {
            return;
        }
        var textArr = attrs.textArr;
        var x = attrs.x;
        var y = attrs.y;
        var maxWidth = attrs.maxWidth;
        context.beginPath();
        if (self.hasStroke()) {
            var strokeOpacity = attrs.strokeOpacity;
            if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {
                context.globalAlpha = strokeOpacity;
            }
            if (textArr) {
                self._drawTextArr(context, false);
            }
            else {
                context.strokeText(text, x, y, maxWidth);
            }
            context.globalAlpha = 1;
        }
        if (self.hasFill()) {
            var fillOpacity = attrs.fillOpacity;
            if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {
                context.globalAlpha = fillOpacity;
            }
            if (textArr) {
                self._drawTextArr(context, true);
            }
            else {
                context.fillText(text, x, y, maxWidth);
            }
        }
        cfg.hasUpdate = false;
    };
    CText.prototype._drawTextArr = function (context, fill) {
        var textArr = this.attrs.textArr;
        var textBaseline = this.attrs.textBaseline;
        var fontSize = this.attrs.fontSize * 1;
        var spaceingY = this._getSpaceingY();
        var x = this.attrs.x;
        var y = this.attrs.y;
        var maxWidth = this.attrs.maxWidth;
        var box = this.getBBox();
        var height = box.maxY - box.minY;
        var subY;
        Util.each(textArr, function (subText, index) {
            subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;
            if (textBaseline === 'middle')
                subY += height - fontSize - (height - fontSize) / 2;
            if (textBaseline === 'top')
                subY += height - fontSize;
            if (fill) {
                context.fillText(subText, x, subY, maxWidth);
            }
            else {
                context.strokeText(subText, x, subY, maxWidth);
            }
        });
    };
    CText.prototype.measureText = function () {
        var self = this;
        var attrs = self.attrs;
        var text = attrs.text;
        var font = attrs.font;
        var textArr = attrs.textArr;
        var measureWidth;
        var width = 0;
        if (Util.isNil(text))
            return undefined;
        var context = document.createElement('canvas').getContext('2d');
        context.save();
        context.font = font;
        if (textArr) {
            Util.each(textArr, function (subText) {
                measureWidth = context.measureText(subText).width;
                if (width < measureWidth) {
                    width = measureWidth;
                }
                context.restore();
            });
        }
        else {
            width = context.measureText(text).width;
            context.restore();
        }
        if (attrs.maxWidth !== undefined) {
            width = Math.min(attrs.maxWidth, width);
        }
        return width;
    };
    return CText;
}(shape_1.default));
exports.default = CText;
//# sourceMappingURL=text.js.map