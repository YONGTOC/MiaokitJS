"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Util = require("@antv/util");
var vec2 = Util.vec2;
var EPSILON = 0.0001;
function at(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
exports.at = at;
function pointDistance(x1, y1, x2, y2, x3, y3, x, y, out) {
    var t;
    var interval = 0.005;
    var d = Infinity;
    var d1;
    var v1;
    var v2;
    var _t;
    var d2;
    var i;
    var v0 = [x, y];
    for (_t = 0; _t < 1; _t += 0.05) {
        v1 = [at(x1, x2, x3, _t), at(y1, y2, y3, _t)];
        d1 = vec2.squaredDistance(v0, v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;
    for (i = 0; i < 32; i++) {
        if (interval < EPSILON) {
            break;
        }
        var prev = t - interval;
        var next = t + interval;
        v1 = [at(x1, x2, x3, prev), at(y1, y2, y3, prev)];
        d1 = vec2.squaredDistance(v0, v1);
        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        }
        else {
            v2 = [at(x1, x2, x3, next), at(y1, y2, y3, next)];
            d2 = vec2.squaredDistance(v0, v2);
            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            }
            else {
                interval *= 0.5;
            }
        }
    }
    if (out) {
        return {
            x: at(x1, x2, x3, t),
            y: at(y1, y2, y3, t),
        };
    }
    return Math.sqrt(d);
}
exports.pointDistance = pointDistance;
function extrema(p0, p1, p2) {
    var a = p0 + p2 - 2 * p1;
    if (Util.isNumberEqual(a, 0)) {
        return [0.5];
    }
    var rst = (p0 - p1) / a;
    if (rst <= 1 && rst >= 0) {
        return [rst];
    }
    return [];
}
exports.extrema = extrema;
function projectPoint(x1, y1, x2, y2, x3, y3, x, y) {
    return pointDistance(x1, y1, x2, y2, x3, y3, x, y, true);
}
exports.projectPoint = projectPoint;
//# sourceMappingURL=quadratic.js.map